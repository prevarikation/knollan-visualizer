<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>speed dial decoder</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<script src="js/AxisIndex.js"></script>
	<script src="js/StateTable.js"></script>
	<script src="js/AxisStates.js"></script>
	<script src="js/blank-reg-locker-unlocker-table.js"></script>
	<script src="js/decoder.js"></script>
	<script>
	/*
	** Expects an array of combinations with form
	** { combo: string, [indicesForMultiplePulls: [number, ...]] }
	*/
	function outputCombinations(combinations) {
		var elements = combinations.map(function(o) {
			var el = document.createElement('div');
			el.classList.add('combination');
			el.innerText = "0 ";

			o.combo.split('')
			  .map((c, i) => ((o.indicesForMultiplePulls && o.indicesForMultiplePulls.includes(i)) || i === o.combo.length-1) ? pullElement(c) : document.createTextNode(" " + c))
			  .forEach(function(e) { el.appendChild(e); });

			return el;
		});

		var outputEl = document.getElementById('combinations');
		outputEl.innerHTML = "";
		outputEl.append.apply(outputEl, elements);

		function pullElement(s) {
			var result = document.createElement('span');
			result.classList.add('pull');
			result.innerText = " " + s;
			return result;
		}
	}

	function matchingLockerUnlockerToCombinations() {
		if (!arguments.length) {
			return lockerUnlockerTable.map(x => lockerUnlockerFormatToCombination(x)); // we need to not pass (x,i) as second argument
		}

		var filterArguments = arguments;
		var tableWithIndices = lockerUnlockerTable.map(chain => chain.map(function(moveSet, idx){ return { index: idx, moveSet: moveSet }; }));
		var filteredTable = tableWithIndices.map(chain => chain.filter(o => stateMatchesFilters(o.moveSet.state, filterArguments)));
		return filteredTable.map(function(chain, i) {
			if (chain.length) {
				return lockerUnlockerFormatToCombination(lockerUnlockerTable[i], chain.map(o => o.index));
			} else {
				return null;
			}
		}).filter(x => x);

		function stateMatchesFilters(state, filters) {
			for (var arg of filters) {
				if (typeof arg === 'function' && !arg({ top: state[0], left: state[1], bottom: state[2], right: state[3] })) {
					return false;
				}
			}
			return true;
		}
	}

	function lockerUnlockerFormatToCombination(format, desiredIndices) {
		if (desiredIndices) {
			if (desiredIndices.length === 1) {
				// only one pull, so we use the most direct route
				var fullCombo = format[desiredIndices[0]].directCombo || format[desiredIndices[0]].moves;
				desiredIndices = [fullCombo.length-1];
			} else {
				// multiple pulls, but possibly limited or intermittent
				var fullCombo = format.filter((x,i) => (i <= Math.max.apply(null, desiredIndices))).map(o => o.moves).join('');
				desiredIndices = desiredIndices.map(x => x + format[0].moves.length-1);
			}
		} else {
			// no info given = pull at the end of every move sequence
			var fullCombo = format.map(o => o.moves).join('');
			desiredIndices = new Array(format.length).fill(true).map((x,i) => i + format[0].moves.length-1);
		}

		return { combo: fullCombo, indicesForMultiplePulls: desiredIndices };
	}

	var decoderHistory = [];
	document.addEventListener('DOMContentLoaded', function(){
		var htmlCards = Array.from(document.querySelectorAll('.card'));
		htmlCards.filter(el => el.id !== 'start').forEach(el => hideCard(el));

		for (const htmlCard of htmlCards) {			
			var cardActions = cards[htmlCard.id];
			if (cardActions) {
				for (const func of Object.keys(cardActions)) {
					if (func === 'setup') {
						cardActions.setup(htmlCard);
					} else {
						htmlCard.addEventListener(func, cardActions[func]);
					}
				}
			}

			// MUST follow card actions, because we want click handlers in setup()s to be added first
			Array.from(htmlCard.querySelectorAll('input[type=button][data-next-card]')).forEach(function(el){
					el.addEventListener('click', transitionCards(htmlCard.id, el.dataset.nextCard));
			});
		}

		Array.from(document.querySelectorAll('input[type=button][data-nav-back]')).forEach(el => el.addEventListener('click', back));
	});

	const cards = {
		'start': {
			setup: function() {
				decoderHistory.push('start');
				document.getElementById('locker-unlocker-only').addEventListener('click', function(){
					document.forms['decoder'].elements['onlyFactoryCombos'].checked = true;
					document.forms['decoder'].elements['onlyFactoryCombos'].disabled = true;
					clearRadioOption('topGatePosition');
				});
				document.getElementById('simplify-possibilities').addEventListener('click', function(){
					document.forms['decoder'].elements['onlyFactoryCombos'].checked = true;//false;
					document.forms['decoder'].elements['onlyFactoryCombos'].removeAttribute('disabled');
				});
			},
			onShow: function(){},
			onHide: function(){}
		},

		'combination-listing': {
			onShow: function(){
				var filters = [];
				var firstBindingDisk = document.forms['decoder'].elements['firstBindingDisk'].value;
				var firstGateSelection = +document.forms['decoder'].elements['topGatePosition'].value;

				if (firstGateSelection > 0) {
					var firstGatePosition = { N: Math.floor((firstGateSelection+1)/3) % 5, M: ((firstGateSelection+1) % 3) - 1 };
					filters.push(gateIs(firstBindingDisk, firstGatePosition));
				}

				var matchingCombinations = null;
				if (document.forms['decoder'].elements['onlyFactoryCombos'].checked) {
					matchingCombinations = matchingLockerUnlockerToCombinations.apply(null, filters);
				} else {
					// calling out to decoder.js here
					matchingCombinations = filterByEndIndices.apply(null, filters).sort(sortEndIndicesByCombinationLength).map(function(c){ return { combo: c.combination }; });
				}

				Array.from(document.querySelectorAll('[data-total-combinations]')).forEach(el => el.innerText = matchingCombinations.map(o => o.indicesForMultiplePulls ? o.indicesForMultiplePulls.length : 1).reduce((a,b) => a+b, 0));

				if (matchingCombinations) {
					outputCombinations(matchingCombinations);
				}
			},
			onHide: function(){
				document.getElementById('combinations').innerHTML = '';
			}
		},

		'identify-first-binding-disk': {
			setup: function() {
				document.forms['decoder'].elements['firstBindingDisk'].addEventListener('change', function(e){
					var firstBindingDisk = e.target.value;
					var steppingDirections = {
						top: ["L", "R", "U"],
						left: ["D", "U", "L"],
						bottom: ["R", "L", "D"],
						right: ["U", "D", "R"],
					};
					for (var i = 1; i <= 3; ++i) {
						document.getElementById('top-gate-direction-' + i).innerText = steppingDirections[firstBindingDisk][i-1];
					}
					Array.from(document.querySelectorAll('[data-stepping-pattern]')).forEach(el => el.innerText = steppingDirections[firstBindingDisk].join(''));
					Array.from(document.querySelectorAll('[data-first-binding-disk]')).forEach(el => el.innerText = firstBindingDisk);
				});
				document.forms['decoder'].elements['firstBindingDisk'].dispatchEvent(new Event('change'));
			}
		},

		'identify-gate-on-first-binding-disk': {
			setup: function(el){
				el.querySelector('[data-next-card=suggest-locker-unlocker]').addEventListener('click', e => clearRadioOption('topGatePosition'));
			},
			onShow: function(){
				document.forms['decoder'].elements['gateTableHeader'].innerText = uppercaseFirst(document.forms['decoder'].elements['gateTableHeader'].innerText);
				function uppercaseFirst(s){ return s[0].toUpperCase() + s.slice(1); }
			}
		}
 	};

	function hideCard(el) { el.style.display = 'none'; el.dispatchEvent(new Event('onHide')); }
	function showCard(el, skipHistory) {
		el.style.display = '';
		el.dispatchEvent(new Event('onShow'));
		if (!skipHistory) {
			decoderHistory.push(el.id);
		};
		window.scrollTo(0,0);
	}
	function transitionCards(prev, next, skipHistory) {
		return function(){
			hideCard(document.getElementById(prev));
			showCard(document.getElementById(next), skipHistory);
		}
	}
	function back() {
		if (decoderHistory.length > 1) {
			transitionCards(decoderHistory.pop(), decoderHistory[decoderHistory.length-1], true)();
		}
	}

	function clearRadioOption(name) {
		document.querySelector('input[name="' + name + '"]:checked').checked = false;
	}
	</script>
	<link href="css/decoder.css" rel="stylesheet">
</head>
<body>

<header>
	<h1>speed dial decoder</h1>
</header>

<form name="decoder">

<nav id="global-nav">
	<ul>
		<li><input type="button" value="Back" data-nav-back=""></li>
		<!--<li><input id='nav-forward' type='button' value='Forward'></li>-->
	</ul>
</nav>

<section id="start" class="card">
	<h2>How would you like to start?</h2>
	<input id="locker-unlocker-only" type="button" value="Let's cover 4-move (factory) codes only" data-next-card="combination-listing">
	<input id="simplify-possibilities" type="button" value="Let's simplify possibilities first" data-next-card="identify-first-binding-disk">	
</section>

<section id="combination-listing" class="card">
	<h2><output data-total-combinations=""></output> matching combinations:</h2>
	<label><input type="checkbox" name="onlyFactoryCombos">Cover 4-move (factory) codes only</label>
	<output id="combinations">will appear here</output>
</section>

<section id="identify-first-binding-disk" class="card">
	<h2>Let's find the first binding disk.</h2>
	<details open>
		<summary>Dial sticking technique</summary>
		<ol>
			<li>Reset.</li>
			<li>For each direction, U, L, R and D, do the following.
				<ol type="a">
					<li>Move the dial in the chosen direction, but hold the dial at the end of its travel.</li>
					<li>Apply light-to-moderate tension on the shackle, enough to bind (ideally) just the first binding disk.</li>
					<li>Release the dial, noting whether the dial sticks or slides freely back to the center.</li>
				</ol>
			</li>
			<li>
			The dial should slide freely in exactly 1 direction, and stick in the 3 other directions. The first binding disk
			is in the <em>opposite</em> direction from the move that slides freely (i.e., if the dial moves on a D move, the
			<strong>top</strong> disk is the first binding disk.)
			</li>
	</details>
	<select name="firstBindingDisk">
		<option value="top" selected="selected">Top</option>
		<option value="left">Left</option>
		<option value="bottom">Bottom</option>
		<option value="right">Right</option>
	</select>
	<hr>
	<input id="found-first-binding-disk" type="button" value="OK" data-next-card="identify-gate-on-first-binding-disk">
	<input type="button" value="I can't find it" data-next-card="suggest-locker-unlocker">
</section>

<section id="identify-gate-on-first-binding-disk" class="card">
	<h2>Let's find the gate for the first binding disk.</h2>
	<details open>
		<summary>Incremental stepping technique</summary>
		<ol>
			<li>Reset.</li>
			<li>Moving the dial in an <output data-stepping-pattern="">LRU</output> pattern rotates the <output data-first-binding-disk="">top</output> wheel clockwise each time, in the smallest increment.</li>
			<li>After each move in the <output data-stepping-pattern="">LRU</output> pattern, move outward, but hold the button at the end of travel and then do the following.
				<ol type="a">
					<li>Apply light-to-moderate tension on the shackle, enough to bind (ideally) just the first disk.</li>
					<li>Release the dial, noting whether the dial sticks or slides freely back to the center.</li>
					<li>If the dial slides freely, then the first disk is still binding and not in a gate.</li>
					<li>If the dial sticks (under appropriate tension,) it means that another disk is now bound, and the fence is in a gate.</li>
					<li>For the Master Lock Speed Dial version, the tolerances seem to allow the fence to move into the gate in two positions — the correct position, and the one immediately before. So as you go around, when there are two consecutive positions that stick, the second position should be the location of the true gate.</li>
				</ol>
			</li>
		</ol>
	</details>
	<h3><output data-first-binding-disk="" name="gateTableHeader">Top</output> gate state table</h3>
	<table id="top-gate-select">
		<thead>
			<tr><th><span id="top-gate-direction-1"></span></th><th><span id="top-gate-direction-2"></span></th><th><span id="top-gate-direction-3"></span></th></tr>
		</thead>
		<tbody>
			<tr>
				<td><label><input type='radio' name='topGatePosition' value='1'><span>(0,1)</span></label></td>
				<td><label><input type='radio' name='topGatePosition' value='2'><span>(1,-1)</span></label></td>
				<td><label><input type='radio' name='topGatePosition' value='3'><span>(1,0)</span></label></td>
			</tr>
			<tr>
				<td><label><input type='radio' name='topGatePosition' value='4'><span>(1,1)</span></label></td>
				<td><label><input type='radio' name='topGatePosition' value='5'><span>(2,-1)</span></label></td>
				<td><label><input type='radio' name='topGatePosition' value='6'><span>(2,0)</span></label></td>
			</tr>
			<tr>
				<td><label><input type='radio' name='topGatePosition' value='7'><span>(2,1)</span></label></td>
				<td><label><input type='radio' name='topGatePosition' value='8'><span>(3,-1)</span></label></td>
				<td><label><input type='radio' name='topGatePosition' value='9'><span>(3,0)</span></label></td>
			</tr>
			<tr>
				<td><label><input type='radio' name='topGatePosition' value='10'><span>(3,1)</span></label></td>
				<td><label><input type='radio' name='topGatePosition' value='11'><span>(4,-1)</span></label></td>
				<td><label><input type='radio' name='topGatePosition' value='12'><span>(4,0)</span></label></td>
			</tr>
			<tr>
				<td><label><input type='radio' name='topGatePosition' value='13'><span>(4,1)</span></label></td>
				<td><label><input type='radio' name='topGatePosition' value='14'><span>(0,-1)</span></label></td>
				<td><label><input type='radio' name='topGatePosition' value='15'><span>(0,0)</span></label></td>
			</tr>
		</tbody>
	</table>
	<hr>
	<input id="found-first-gate" type="button" value="OK" data-next-card="combination-listing">
	<input type="button" value="I can't find it" data-next-card="suggest-locker-unlocker">
</section>

<section id="suggest-locker-unlocker" class="card">
	<h2>try locker unlocker?</h2>
	<input type="button" value="OK" data-next-card="combination-listing">
	<input type="button" value="Let me try again" data-nav-back="">
</section>

<section id="" class="card">
	<h2>title</h2>
	<input type="button" value="OK" data-next-card="">
	<input type="button" value="Let me try again" data-nav-back="">
</section>

</form>

<!--
<ol>

<li>
<h2>Identify second binding disk:</h2>
<h3>Enter sequence:</h3>
<output id='top-gate-sequence' class='mono-output short-generate'>&nbsp;</output>
<p>
    Mark the downward move count (cyclical) that has a distinct click or the <em>most</em> outward shackle movement:
</p>
<ul>
	<li><label><input class="downward-stick" type="checkbox"> 1</label></li>
	<li><label><input class="downward-stick" type="checkbox"> 2</label></li>
	<li><label><input class="downward-stick" type="checkbox"> 3</label></li>
	<li><label><input class="downward-stick" type="checkbox"> 4</label></li>
	<li><label><input class="downward-stick" type="checkbox"> 5</label></li>
    <li><label><input class="downward-stick" type="checkbox"> I can't find one</label></li>
</ul>

<h3>Enter 2<sup>nd</sup> sequence:</h3>
<output id='top-gate-sequence' class='mono-output short-generate'>R D &nbsp;</output>
<p>
    Again, mark the downward move count (cyclical) that has a distinct click or the <em>most</em> outward shackle movement:
</p>
<ul>
    <li><label><input class="downward-stick" type="checkbox"> 1</label></li>
    <li><label><input class="downward-stick" type="checkbox"> 2</label></li>
    <li><label><input class="downward-stick" type="checkbox"> 3</label></li>
    <li><label><input class="downward-stick" type="checkbox"> 4</label></li>
    <li><label><input class="downward-stick" type="checkbox"> 5</label></li>
</ul>

<h3>Second binding disk:
<select id="second-binding-disk" disabled="disabled">
    <option value="top">Top</option>
    <option value="left">Left</option>
    <option value="bottom">Bottom</option>
    <option value="right" selected="selected">Right</option>
</select>
</h3>
</li>


<li>
<h2>Identify correct gate for second binding disk:</h2>
<p>
Use observation from <a href="https://blackbag.toool.nl/?p=183#comment-181131">Master Unlocked on blackbag.toool.nl</a>, about being able to determine the final and second-to-last movements when moving the knob 5 times in the same direction. This, combined with Blank_Reg's "wheel gate location map," mentioned in the locker unlocker instructions, simplifies the process of guesstimating the correct gate on the second disk.
</p>
</li>

</ol>
</form>
-->

</body>
</html>
